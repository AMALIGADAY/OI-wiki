author: CBW2007, ChungZH, Marcythm, abc1763613206, Ir1d, AMALIGADAY

## 前言

DFS（深度优先搜索）是一种常见的算法，很多题目都可以用 DFS 解决，但是大部分情况下，这都是骗分算法。因为很多时候 DFS 的时间复杂度特别高，比如全排列、枚举子集、枚举分组等等，数据范围大一点就不行了。

既然不能成为正解，那就多骗一点分吧。那么这一篇文章将介绍一些实用的优化算法。

先来一段深搜模板，之后的模板将在此基础上进行修改。

注意，这只是一个例子，很多时候的实际实现会复杂的多，详见 [DFS（搜索）](https://oi-wiki.org/search/dfs/)。

```cpp
int ans = 最坏情况;  // ans 代表已知解中的最优解
void dfs(状态) {
  if (到达终态) ans = 从当前解与 ans 中选最优;
  for (遍历所有下一步可能性)
    if (可行) {
      进行操作;
      dfs(下一个状态);
      撤回操作;
    }
}
```

## 剪枝方法

最常用的剪枝有三种，记忆化剪枝、最优性剪枝、可行性剪枝。

### 记忆化剪枝

因为在搜索中，相同的传入值往往会带来相同的解，那我们就可以直接跳过这样的搜索，避免重复。

（如果需要记录答案，详见 [记忆化搜索](../dp/memo.md)。）

**模板：**

```cpp
int vst[MAXN];  // 记录状态是否被搜索过
int ans = 最坏情况;
void dfs(状态) {
  if (vst[状态]) return;
  vst[状态] = 1;
  if (到达终态) ans = 从当前解与 ans 中选最优;
  for (遍历所有下一步可能性)
    if (可行) {
      进行操作;
      dfs(下一个状态);
      撤回操作;
    }
}
```

### 最优性剪枝

在搜索中导致运行慢的原因还有一种，就是在当前解已经比已有解差时仍然在搜索，那么我们只需要判断一下当前解是否已经差于已有解。

或者，之后无论进行何种操作都无法已有解更优，那么一样可以剪枝。

**模板：**

```cpp
int ans = 最坏情况;
void dfs(状态) {
  if (当前解比 ans 还要差) return;
  if (到达终态) ans = 从当前解与 ans 中选最优;
  for (遍历所有下一步可能性)
    if (可行) {
      进行操作;
      dfs(下一个状态);
      撤回操作;
    }
}
```

### 可行性剪枝

在搜索过程中当前解已经不合法了还继续搜索下去也是运行慢的原因。

**模板：**

```cpp
int ans = 最坏情况;
void dfs(状态) {
  if (当前解已经不合法) return;
  if (到达终态) ans = 从当前解与 ans 中选最优;
  for (遍历所有下一步可能性)
    if (可行) {
      进行操作;
      dfs(下一个状态);
      撤回操作;
    }
}
```

## 剪枝思路

剪枝思路有很多种，大多需要对于具体问题来分析，在此简要介绍几种常见的剪枝思路。

- 极端法：考虑极端情况，如果最极端（最理想）的情况都无法满足，那么肯定实际情况搜出来的结果不会更优了。

- 调整法：通过对子树的比较剪掉重复子树和明显劣于其他子树的子树。

- 数学方法：比如在图论中借助连通分量，数论中借助模方程的分析，借助不等式的放缩来估计下界等等。

## 启发式搜索

先搜索较优解，可以在可行性问题中发挥奇效；就算是最优性问题，先搜索较优解再搭配上强制时间截断也可以取得意想不到的成绩。

## 例题

### 例题 1

???+note "工作分配问题"
    **题目描述**
    
    有 $n$ 份工作要分配给 $n$ 个人来完成，每个人完成一份。第 $i$ 个人完成第 $k$ 份工作所用的时间为一个正整数 $t_{i,k}$，其中 $1 \leq i, k \leq n$。试确定一个分配方案，使得完成这 $n$ 份工作的时间总和最小。
    
    输入包含 $n + 1$ 行。
    
    第 1 行为一个正整数 $n$。
    
    第 2 行到第 $n + 1$ 行中每行都包含 $n$ 个正整数，形成了一个 $n \times n$ 的矩阵。在该矩阵中，第 $i$ 行第 $k$ 列元素 $t_{i,k}$ 表示第 $i$ 个人完成第 $k$ 件工作所要用的时间。
    
    输出包含一个正整数，表示所有分配方案中最小的时间总和。
    
    **数据范围**
    
    $1 \leq n \leq  15$
    
    $1 \leq t_{i,k} \leq 10^4$
    
    **输入样例**
    
    ```text
    5
    9 2 9 1 9
    1 9 8 9 6
    9 9 9 9 1
    8 8 1 8 4
    9 1 7 8 9
    ```
    
    **输出样例**
    
    ```text
    5
    ```

??? note "解法"
    由于每个人都必须分配到工作，在这里可以建一个二维数组 `time[i][j]`，表示 $i$ 个人完成 $j$ 号工作所花费的时间。给定一个循环，从第 1 个人开始循环分配工作，直到所有人都分配到。为第 $i$ 个人分配工作时，再循环检查每个工作是否已被分配，没有则分配给 $i$ 个人，否则检查下一个工作。可以用一个一维数组 `is_working[j]` 来表示第 $j$ 号工作是否已被分配，未分配则 `is_working[j]=0`，否则 `is_working[j]=1`。利用回溯思想，在工人循环结束后回到上一工人，取消此次分配的工作，而去分配下一工作直到可以分配为止。这样，一直回溯到第 1 个工人后，就能得到所有的可行解。
    
    检查工作分配，其实就是判断取得可行解时的二维数组的第一维下标各不相同并且第二维下标各不相同。而我们是要得到完成这 $n$ 份工作的最小时间总和，即可行解中时间总和最小的一个，故需要再定义一个全局变量 `cost_time_total_min` 表示目前找到的解中最小的时间总和，初始 `cost_time_total_min` 为 `time[i][i]` 之和，即对角线工作时间相加之和。在所有人分配完工作时，比较 `count` 与 `cost_time_total_min` 的大小，如果 `count` 小于 `cost_time_total_min`，说明找到了一个最优解，此时就把 `count` 赋给 `cost_time_total_min`。
    
    但考虑到算法的效率，这里还有一个剪枝优化的工作可以做。就是在每次计算局部费用变量 `count` 的值时，如果判断 `count` 已经大于 `cost_time_total_min`，就没必要再往下分配了，因为这时得到的解必然不是最优解。

??? note "参考代码"
    ```C++
    --8<-- "docs/search/code/opt/opt_1.cpp"
    ```

### 例题 2

???+note "[luogu P1120 小木棍 ［数据加强版］](https://www.luogu.com.cn/problem/P1120)"
    **题目描述**
    
    乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过 $50$。
    
    现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。
    
    给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。
    
    **输入格式**
    
    共二行。
    
    第一行为一个单独的整数 $N$ 表示砍过以后的小木棍的总数，其中 $N≤65$。
    
    第二行为 $N$ 个用空个隔开的正整数，表示 $N$ 根小木棍的长度。
    
    **输出格式**
    
    一个数，表示要求的原始木棍的最小可能长度。

??? note "题解"
    这是一道剪枝圣题。
    
    咕咕咕。
    
    [参考题解]\(<https://www.luogu.com.cn/blog/Kaori/solution-p1120>

??? note "参考代码"
    ```C++
    #include <bits/stdc++.h>
    using namespace std;
    inline int read() {
      int x = 0;
      bool f = 1;
      char c = getchar();
      for (; !isdigit(c); c = getchar())
        if (c == '-') f = 0;
      for (; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + c - '0';
      if (f) return x;
      return 0 - x;
    }
    int n, m, a[66], next[66], cnt, sum, len;
    bool used[66],
        ok;  // used数组即优化5的vis数组，记录每根木棍是否用过；ok记录是否已找到答案。
    bool cmp(int a, int b) { return a > b; }
    void dfs(
        int k, int last,
        int rest) {  // k为正在拼的木棍的编号，last为正在拼的木棍的前一节编号，rest为该木棍还未拼的长度
      int i;
      if (!rest) {  //未拼的长度为0，说明这根原始长棍拼完了，准备拼下一个
        if (k == m) {
          ok = 1;
          return;
        }  //优化6，全部拼完并符合要求，找到答案，直接返回
    
        for (
            i = 1; i <= cnt;
            i++)  //找一个还没用的最长的木棍打头即可。反正要想全都拼接成功，每根木棍都得用上
          if (!used[i]) break;
        used[i] = 1;
        dfs(k + 1, i, len - a[i]);
        used[i] = 0;
        if (ok) return;  //优化6，找到答案就退出
      }
      //优化4，二分找第一个 木棍长度不大于未拼长度rest 的位置
      int l = last + 1, r = cnt, mid;
      while (l < r) {
        mid = (l + r) >> 1;
        if (a[mid] <= rest)
          r = mid;
        else
          l = mid + 1;
      }
      for (i = l; i <= cnt; i++) {
        if (!used[i]) {  //优化5，判断木棍是否用过
          used[i] = 1;
          dfs(k, i, rest - a[i]);
          used[i] = 0;
          if (ok) return;  //优化6，找到答案就退出
    
          if (rest == a[i] || rest == len) return;  //优化7
          i = next[i];                              //优化3
          if (i == cnt) return;
        }
      }
      //到了这里，说明这时候拼不成当前这根原始木棍了，传回失败信息并修改之前拼的木棍
    }
    int main() {
      n = read();
      int d;
      for (int i = 1; i <= n; i++) {
        d = read();
        if (d > 50) continue;
        a[++cnt] = d;
        sum += d;
      }
      sort(a + 1, a + cnt + 1, cmp);  //优化1，木棍按长度从大到小排序
      //优化3，预处理next数组
      next[cnt] = cnt;
      for (int i = cnt - 1; i > 0; i--) {
        if (a[i] == a[i + 1])
          next[i] = next[i + 1];
        else
          next[i] = i;
      }
      for (len = a[1]; len <= sum / 2; len++) {  //枚举原始长度
        if (sum % len != 0) continue;  //如果不能拼出整数根 就跳过
        m = sum / len;                 //优化6中的那个计算
        ok = 0;
        used[1] = 1;
        dfs(1, 1, len - a[1]);
        used[1] = 0;
        if (ok) {
          printf("%d\n", len);
          return 0;
        }  //优化6，输出答案，退
      }
      printf("%d\n", sum);
      return 0;
    }
    ```
